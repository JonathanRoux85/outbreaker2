---
title: "Analysis of Bayesian results"
author: "Jonathan Roux"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  word_document: default
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=TRUE, warning=FALSE, include=FALSE}
##############################
#### Loading of libraries ####
##############################
library(data.table)
library(knitr)
library(ggplot2)
library(ggrepel)

##########################################
#### Loading of chains_detect100_bind ####
##########################################
load("../StageCRENet/hackathon/outbreaker/data/data1.Rdata")
load("../StageCRENet/hackathon/outbreaker/chains/chains1.Rdata")

## Preparation of data ##
detect100 <- data$detect100
chains_detect100 <- chains$detect100

chains_detect100_bind <- rbindlist(chains_detect100)
setnames(chains_detect100_bind, 
         c("hospID","origin"),
         c("to","from"))

# Keeping in mind the chains #
counter <- 0
for(i in 1:chains_detect100_bind[,.N]){
  if(chains_detect100_bind[i, is.na(from)])
    counter <- counter + 1
  chains_detect100_bind[i, chain := counter]
}

# Length of chains #
lengths_chains <- chains_detect100_bind[, .N, by = "chain"]
chains_detect100_bind <- merge(chains_detect100_bind,
                               lengths_chains[, .(chain,
                                                  length_chain = N-1)],
                               by = "chain")

## Preparation of chains_detect100_bind to facilitate the computation of parameters ##
detect100[,num := seq_len(.N)]

chains_detect100_bind.2 <- merge(chains_detect100_bind,
                                 detect100[,.(hospID, t_descendant = t,
                                              t_detect_descendant = t_detect, 
                                              num)],
                                 by.x = c("to", "t_detect"),
                                 by.y = c("hospID","t_detect_descendant"))
chains_detect100_bind.2 <- merge(chains_detect100_bind.2,
                                 detect100[,.(hospID, 
                                              t_ancestor = t, 
                                              num)],
                                 by.x = c("from"),
                                 by.y = c("hospID"),
                                 all.x=TRUE)
chains_detect100_bind.2 <- chains_detect100_bind.2[t_ancestor<t | is.na(from)]
chains_detect100_bind.2 <- chains_detect100_bind.2[order(to, t, t_ancestor)]
chains_detect100_bind.2 <- chains_detect100_bind.2[,.SD[.N],
                                                   by = c("from", "to", "t")]
# chains_detect100_bind.2[, t.y := NULL]
setnames(chains_detect100_bind.2, c("num.x","num.y"), c("ids_to","ids_from"))

detect100[, num := NULL]

chains_detect100_bind <- chains_detect100_bind.2


###################################################
#### Loading of data of chains' reconstruction ####
###################################################
# Number of scenarii #
no_scenarii <- 3

# Loading of data #
# results_1 <- readRDS("./tmp_results/Ordi/1-results_50000_5_parLapply_scenario1.rds")
# results_2 <- readRDS("./tmp_results/Genouest/1-results_50000_5_parLapply_scenario2.rds")
# results_3 <- readRDS("./tmp_results/Ordi/1-results_50000_5_parLapply_scenario3.rds")

##########################
#### Global variables ####
##########################
# Burning period #
vec_burning <- rep(500, no_scenarii)
# Thinning #
thinning <- rep(5, no_scenarii)
# No iterations #
no_iter <- rep(50000, no_scenarii)
# Adding noise on dates of infection #
adding_noise <- c("-", "P(3.5)", "P(7)")
# Minimal support #
min.support <- 10^(-seq(0, 4, by = 0.05))

###################################
#### Computation of parameters ####
###################################
ParametersSynthesis <- function(index, vec_burning){
  cat(paste0("Scenario ", index, "\n"))
  results <- readRDS(paste0("./tmp_results/Ordi/1-results_50000_5_parLapply_scenario", index, ".rds"))
  burning <- vec_burning[index]
  
  ### Global parameters ###
  # Pi #
  pi <- unlist(lapply(results, 
                      function(r) {
                        r$results_mcmc$res[r$results_mcmc$res$step>burning,]$pi
                        }    
                      )
               )
  # quantile(pi, c(0.025,0.5,0.975))

  # Sigma #
  sigma <- unlist(lapply(results, 
                         function(r) {
                           r$results_mcmc$res[r$results_mcmc$res$step>burning,]$sigma
                         }  
                         )
                  )
  # quantile(sigma, c(0.025,0.5,0.975))

  # Poisson scale #
  poisson_scale <- unlist(lapply(results, 
                                 function(r) {
                                   r$results_mcmc$res[r$results_mcmc$res$step>burning,]$poisson_scale
                                   }   
                                 )
                          )
  # quantile(poisson_scale, c(0.025,0.5,0.975))
  
  # Median Shannon entropy #
  # Already computed using burning period #
  median_shannon_entropy <- unlist(lapply(results, 
                                          function(r) {
                                            r$results_mcmc$res_aa[to %in%
                                                                    chains_detect100_bind[,ids_to],
                                                                .(result=-sum(support*log(support))),
                                                                by="to"][,result]
                                            }    
                                          )
                                   )
  # quantile(median_shannon_entropy, c(0.025,0.5,0.975))

  ### Consensus ancestor ###
  # Already computed using burning period #
  # Number of true positive links #
  tp_links.consensus <- unlist(lapply(results, 
                                      function(r) {
                                        r$parameters$parameters_links_consensus$tp_links.consensus
                                        }           
                                      )
                               )
  # quantile(tp_links.consensus, c(0.025,0.5,0.975))

  # Sensitivity #
  se_links.consensus <- unlist(lapply(results, 
                                      function(r) {
                                        r$parameters$parameters_links_consensus$se_links.consensus
                                        }  
                                    )
                               )
  # quantile(se_links.consensus, c(0.025,0.5,0.975))
  
  # Percentage of global chains reconstructed #
  global_chains_consensus <- unlist(lapply(results, 
                                           function(r) {
                                     r$parameters$parameters_chains_consensus$global_chains_consensus
                                             }  
                                     )
                                    )
  # quantile(global_chains_consensus, c(0.025,0.5,0.975))

  ### All ancestors ###
  # Sensitvity #
  se_links.aa <- unlist(lapply(results, 
                               function(r) {
                                 r$parameters$parameters_links_aa$se_links.aa
                                 }  
                               )
                        )
  # quantile(se_links.aa, c(0.025,0.5,0.975))

  # Maximum sensitivity #
  se_links.aa_max <- unlist(lapply(results, 
                                   function(r) {
                                     max(r$parameters$parameters_links_aa$se_links.aa)
                                     }  
                                   )
                            )
  # quantile(se_links.aa_max, c(0.025,0.5,0.975))

  # ID of the maximum sensitivity #
  se_max_id <- unlist(lapply(results, 
                             function(r) {
                               which(r$parameters$parameters_links_aa$se_links.aa == 
                                       max(r$parameters$parameters_links_aa$se_links.aa))[1]
                               }  
                             )
                      )

  # Specificity #
  sp_links.aa <- unlist(lapply(results, 
                               function(r) {
                                 r$parameters$parameters_links_aa$sp_links.aa
                                 }  
                               )
                        )
  # quantile(sp_links.aa, c(0.025,0.5,0.975))

  # Specificity related to maximum sensitivity #
  sp_links.aa_related_se <- mapply(function(r, id) {
    r$parameters$parameters_links_aa$sp_links.aa[id]
    },
    results,
    se_max_id)
  # quantile(sp_links.aa_related_se, c(0.025,0.5,0.975))

  # Number of links correctly retrieved #
  tp_links.aa <- unlist(lapply(results, 
                               function(r) {
                                 r$parameters$parameters_links_aa$tp_links.aa
                                 }  
                               )
                        )
  # quantile(tp_links.aa, c(0.025,0.5,0.975))

  # Number of links correctly retrieved related to maximum sensitivity #
  tp_links.aa_related_se <- mapply(function(r, id) {
    r$parameters$parameters_links_aa$tp_links.aa[id]
    },
    results,
    se_max_id)
  # quantile(tp_links.aa_related_se, c(0.025,0.5,0.975))
  
  # Minimal support related to maximum sensitivity #
  minimal_support.aa_related_se <- mapply(function(r, id) {
    r$parameters$minimal_support[id]
    },
    results,
    se_max_id)
  # quantile(minimal_support.aa_related_se, c(0.025,0.5,0.975))

  # Positive predictive value #
  ppv_links.aa <- unlist(lapply(results, 
                                function(r) {
                                  r$parameters$parameters_links_aa$ppv_links.aa
                                } 
                                )
                         )
  # quantile(ppv_links.aa, c(0.025,0.5,0.975))

  # Positive predictive value retrieved related to maximum sensitivity #
  ppv_links.aa_related_se <- mapply(function(r, id) {
    r$parameters$parameters_links_aa$ppv_links.aa[id]
    },
    results,
    se_max_id)
  # quantile(ppv_links.aa_related_se, c(0.025,0.5,0.975))

  # Negative predictive value #
  npv_links.aa <- unlist(lapply(results, 
                                function(r) {
                                  r$parameters$parameters_links_aa$npv_links.aa
                                  }  
                                )
                         )
  # quantile(npv_links.aa, c(0.025,0.5,0.975), na.rm = TRUE)

  # Negative predictive value related to maximum sensitivity #
  npv_links.aa_related_se <- mapply(function(r, id) {
    r$parameters$parameters_links_aa$npv_links.aa[id]
    },
    results,
    se_max_id)
  # quantile(npv_links.aa_related_se, c(0.025,0.5,0.975), na.rm = TRUE)

  # Percentage of entire chains reconstructed #
  global_chains_aa <- unlist(lapply(results, 
                                    function(r) {
                                      r$parameters$parameters_chains_aa$global_chains_aa
                                      }  
                                    )
                             )
  # quantile(global_chains_aa, c(0.025,0.5,0.975), na.rm = TRUE)

  # Percentage of entire chains reconstructed related to maximum sensitivity #
  global_chains_aa_related_se <- mapply(function(r, id) {
    r$parameters$parameters_chains_aa$global_chains_aa[id]
    },
    results,
    se_max_id)
  # quantile(global_chains_aa_related_se, c(0.025,0.5,0.975), na.rm = TRUE)
  
  ParametersEditing <- function(ResultVector){
    quantiles <- round(quantile(ResultVector, 
                                c(0.025,0.5,0.975), 
                                na.rm = TRUE),
                       2)
    return(paste0(quantiles[2], 
                  " [", quantiles[1], "-",
                  quantiles[3], "]"))
  }
  
  output <- data.table(pi = ParametersEditing(pi),
                         sigma = ParametersEditing(sigma),
                         poisson_scale = ParametersEditing(poisson_scale),
                         shannon_entropy = ParametersEditing(median_shannon_entropy),
                         tp_links.consensus = ParametersEditing(tp_links.consensus),
                         se_links.consensus = ParametersEditing(se_links.consensus),
                         global_chains_consensus = ParametersEditing(global_chains_consensus),
                         se_links.aa = ParametersEditing(se_links.aa),
                         sp_links.aa = ParametersEditing(sp_links.aa),
                         tp_links.aa = ParametersEditing(tp_links.aa),
                         ppv_links.aa = ParametersEditing(ppv_links.aa),
                         npv_links.aa = ParametersEditing(npv_links.aa),
                         global_chains_aa = ParametersEditing(global_chains_aa),
                         se_links.aa_max = ParametersEditing(se_links.aa_max),
                         minimal_support.aa_related_se = ParametersEditing(minimal_support.aa_related_se),
                         tp_links.aa_related_se = ParametersEditing(tp_links.aa_related_se),
                         sp_links.aa_related_se = ParametersEditing(sp_links.aa_related_se),
                         ppv_links.aa_related_se = ParametersEditing(ppv_links.aa_related_se),
                         npv_links.aa_related_se = ParametersEditing(npv_links.aa_related_se),
                         global_chains_aa_related_se = ParametersEditing(global_chains_aa_related_se)
                         )
  
  ## Plot of ROC curve ##
  # Preparation of data #
  ParametersAccordingSupport <- function(i, results, min.support){
    se_links <- quantile(unlist(lapply(results, 
                                        function(r) {
                                          r$parameters$parameters_links_aa$se_links.aa[i]
                                          }  
                                        )),
                          c(0.025,0.5,0.975))
    sp_links <- quantile(unlist(lapply(results,
                                       function(r) {
                                         r$parameters$parameters_links_aa$sp_links.aa[i]
                                         }  
                                       )),
                         c(0.025,0.5,0.975))
    return(list(min.support = min.support[i],
                se_2.5 = se_links[1],
                se_50 = se_links [2],
                se_97.5 = se_links[3],
                sp_2.5 = sp_links[1],
                sp_50 = sp_links [2],
                sp_97.5 = sp_links[3]))
  }
  
  data_ROC <- rbindlist(lapply(seq_len(length(min.support)), 
                               FUN = ParametersAccordingSupport, 
                               results = results, 
                               min.support = min.support))
  
  
  
  data_ROC[, min.support_label := as.character(round(min.support, 4))]
  data_ROC[, no_line := .I]
  data_ROC[!no_line %in% seq(1,.N,10),
           min.support_label := ""]

  FigPlot <- ggplot(data = data_ROC, aes(x = 1-sp_50, y = se_50)) + 
    geom_rect(aes(xmin = 1-sp_97.5, xmax = 1-sp_2.5,
                  ymin = se_2.5, ymax = se_97.5), fill = '#FF4040') +
    geom_line() +
    geom_point() +
    theme_minimal() +
    xlab("1-specificity") +
    ylab("Sensitivity") +
    ylim(c(0,1)) + 
    xlim(c(0,1)) +
    geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), 
                 colour = "red", linetype = 2, size = 0.75) +
    geom_text_repel(label = data_ROC$min.support_label,
                    box.padding = 1) +
    ggtitle(paste0("Scenario ", index))
  
  rm(results)
  gc()
  
  return(list(output = output,
              ROC = FigPlot))
}

result_function <- lapply(1:no_scenarii, 
                          ParametersSynthesis, 
                          vec_burning = vec_burning)

output <- t(cbind(no_iter = no_iter,
                  thinning = thinning,
                  burning = vec_burning,
                  adding_noise = adding_noise,
                  rbindlist(lapply(result_function,
                                   function(r) {
                                     r$output
                                     }
                                   )
                            )
                  )
            )

output.dt <- as.data.table(output)
names(output.dt) <- as.character(paste0("Scenario ",1:no_scenarii))


output.dt[, parameter := c("No. of iterations", "Thinning", "Burning period",
                           "Noise added", 
                           "Value of pi", "Value of sigma",
                           "Value of poisson_scale", "Shannon entropy",
                           "Consensus-No links retrieved",
                           "Consensus-Sensitivity", "Consensus-% chains reconstructed",
                           "All ancestors-Sensitivity", "All ancestors-Specificity",
                           "All ancestors-No links retrieved", "All ancestors-PPV", 
                           "All ancestors-NPV", "All ancestors-% chains reconstructed",
                           "All ancestors-Maximum sensitivity",
                           "All ancestors-Related minimal support",
                           "All ancestors-Related no links retrieved",
                           "All ancestors-Related specificity",
                           "All ancestors-Related PPV", 
                           "All ancestors-Related NPV", 
                           "All ancestors-Related % chains reconstructed")]

setcolorder(output.dt, "parameter")
```

```{r echo=FALSE,warning=FALSE,results="asis", message=FALSE}
kable(output.dt)

lapply(result_function,
       function(r) {
         r$ROC
         }
       )
```
